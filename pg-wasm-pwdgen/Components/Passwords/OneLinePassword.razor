@using PG.Logic.Passwords.Generators
@using PG.Logic.Passwords.Generators.Entities
@using PG.Wasm.PasswordGenerator.Components.Passwords.Models

@code {
	[Parameter]
	public PasswordResult? Password { get; set; }

	[Parameter]
	public PasswordSize Size { get; set; } = PasswordSize.Small;
}

@if (Password != null)
{
	<div class="row m-0 flex-nowrap">
		<div class="fixed align-self-center px-1 py-0" style="width: auto">
			<LevelWidget Height="36" Level="@TrueLevel"
									 CommentHtml="@(@$"<h5>Entropy (true)</h5> <h4>{TrueEntropyText}</h4> <p class=""text-muted"">{TrueEntropyDescription}</p>")" />
			<span>|</span>
			<LevelWidget Height="36" Level="@DerivedLevel"
									 CommentHtml="@(@$"<h5>Entropy (derived)</h5> <h4>{DerivedEntropyText}</h4> <p class=""text-muted"">{DerivedEntropyDescription}</p>")" />
		</div>
		<div class="col align-self-center px-3 py-0">
			<span class="password" style="@(PasswordStyle)">@Password.Password</span>
		</div>
	</div>
}

@code {
	private int TrueLevel { get => GetLevel(Password?.TrueEntropy); }
	private int DerivedLevel { get => GetLevel(Password?.DerivedEntropy); }
	private string TrueEntropyText { get => GenerateEntropyDescription(Password?.TrueEntropy); }
	private string DerivedEntropyText { get => GenerateEntropyDescription(Password?.DerivedEntropy); }
	private string TrueEntropyDescription { get => "Is calculated based on the number of possible combinations occurred during the password generation."; }
	private string DerivedEntropyDescription { get => "Is calculated based on the generated password, based on the different types of characters and the password length."; }

	private string PasswordStyle
	{
		get => Size switch
		{
			PasswordSize.Small => "font-size: 0.9rem;",
			PasswordSize.Medium => "font-size: 1.2rem;",
			PasswordSize.Large => "font-size: 1.5rem;",
			_ => "font-size: 1rem;",
		};
	}

	private int GetLevel(double? entropy)
	{
		if (!entropy.HasValue) return -1;

		var strength = PasswordGeneratorBase.CalculateStrength(entropy.Value);
		return (int)strength;
	}

	private string GenerateEntropyDescription(double? entropy)
	{
		if (!entropy.HasValue) return string.Empty;

		return entropy.HasValue ? $"{entropy:F2} bits ({GetEntropyStrengthText(entropy.Value)})" : string.Empty;
	}

	private string GetEntropyStrengthText(double entropy)
	{
		var strength = PasswordGeneratorBase.CalculateStrength(entropy);
		return GetEntropyStrengthText(strength);
	}

	private string GetEntropyStrengthText(PasswordStrength strength)
	{
		return strength switch
		{
			PasswordStrength.VeryWeak => "Very weak",
			PasswordStrength.Weak => "Weak",
			PasswordStrength.Reasonable => "Medium",
			PasswordStrength.Strong => "Strong",
			PasswordStrength.VeryStrong => "Very strong",
			_ => "Unknown",
		};
	}
}